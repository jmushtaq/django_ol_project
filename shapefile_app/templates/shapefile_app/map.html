<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Shapefile Viewer</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@8.2.0/ol.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
  <style>
    .map {
      width: 100%;
      height: 600px;
    }
    .layer-control {
      position: absolute;
      top: 8.5em;
      left: 3.5em;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      z-index: 1000;
      max-width: 250px;
    }
    .layer-control-header {
      padding: 0.5em;
      border-bottom: 1px solid #dee2e6;
      background: rgba(248, 249, 250, 0.9);
      font-weight: bold;
      font-size: 0.9em;
    }
    .layer-control-body {
      padding: 0.5em;
      max-height: 400px;
      overflow-y: auto;
    }
    .layer-group {
      margin-bottom: 0.5em;
      padding-bottom: 0.5em;
      border-bottom: 1px solid #eee;
    }
    .layer-group:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }
    .form-check {
      margin-bottom: 0.25em;
    }
    .form-check-label {
      font-size: 0.8em;
    }
    .btn-sm {
      font-size: 0.7em;
      padding: 0.2em 0.5em;
    }
    .layer-toggle {
      position: absolute;
      top: 9.5em;
      left: 1.0em;
      z-index: 1000;
    }
    .layer-toggle-btn {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 2em;
      height: 2em;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .layer-toggle-btn:hover {
      background: white;
    }
    .bi-layers {
      font-size: 1em;
    }
    .selection-info {
      background: rgba(248, 249, 250, 0.8);
      padding: 0.5em;
      border-radius: 3px;
      border-left: 3px solid #28a745;
    }
    .annotation-toggle-btn:hover {
        background: white !important;
    }

    .bi-123 {
        font-size: 1em;
    }
  </style>
</head>
<body>
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
    <div class="container">
      <a class="navbar-brand" href="{% url 'map_view' %}">Shapefile Viewer</a>
      <div class="navbar-nav">
        <a class="nav-link" href="{% url 'upload_shapefile' %}">Upload Shapefile</a>
      </div>
    </div>
  </nav>

  <div class="container-fluid mt-3">
    <div id="map" class="map"></div>
  </div>

  <!-- Add this temporarily for debugging -->
  <div style="position: absolute; bottom: 10px; left: 10px; background: white; padding: 10px; z-index: 1000;">
    <div id="debug-info" class="small"></div>
  </div>

  <!-- Layer Toggle Icon -->
  <div class="layer-toggle">
    <div class="layer-toggle-btn" id="layer-toggle-btn" title="Toggle Layers">
      <i class="bi bi-layers"></i>
    </div>
  </div>

    <!-- Add annotation toggle button next to layer toggle -->
    <div class="annotation-toggle" style="position: absolute; top: 4.5em; left: 3em; z-index: 1000;">
        <div class="annotation-toggle-btn" id="annotation-toggle-btn" title="Toggle Annotations" style="background: rgba(255, 255, 255, 0.9); border: 1px solid #ccc; border-radius: 4px; width: 2em; height: 2em; display: flex; align-items: center; justify-content: center; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">
            <i class="bi bi-123"></i>
        </div>
    </div>

  <!-- Layer Control Panel (hidden by default) -->
  <div id="layer-control" class="layer-control" style="display: none;">
    <div class="layer-control-header">
      Layers
    </div>
    <div class="layer-control-body">
      <div id="layer-list">
        {% for shapefile in shapefiles %}
        <div class="layer-group">
          <div class="form-check">
            <input class="form-check-input layer-checkbox" 
                   type="checkbox" 
                   value="{{ shapefile.id }}" 
                   id="layer{{ shapefile.id }}"
                   data-layer-type="original"
                   checked>
            <label class="form-check-label" for="layer{{ shapefile.id }}">
              {{ shapefile.name }} (O)
            </label>
          </div>
          
          {% if shapefile.geojson_data_processed %}
          <div class="form-check ms-3">
            <input class="form-check-input layer-checkbox" 
                   type="checkbox" 
                   value="{{ shapefile.id }}" 
                   id="layer{{ shapefile.id }}_processed"
                   data-layer-type="processed"
                   checked>
            <label class="form-check-label" for="layer{{ shapefile.id }}_processed">
              {{ shapefile.name }} (P)
            </label>
          </div>
          {% endif %}
          
          <div class="mt-1">
            <a href="{% url 'debug_shapefile' shapefile.id %}" class="btn btn-sm btn-outline-info" target="_blank">
              Debug
            </a>
          </div>
        </div>
        {% empty %}
        <p class="text-muted small">No shapefiles uploaded yet.</p>
        {% endfor %}
      </div>
      
      <div class="mt-3">
        <a href="{% url 'upload_shapefile' %}" class="btn btn-primary btn-sm w-100">Upload New Shapefile</a>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/ol@8.2.0/dist/ol.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
<script>
    // Western Australia bounds (approximate)
    const WA_BOUNDS = [112.5, -35.5, 129.0, -13.5];

    // Initialize map with default controls (includes zoom buttons)
    const map = new ol.Map({
        target: 'map',
        layers: [
            new ol.layer.Tile({
                source: new ol.source.OSM()
            })
        ],
        view: new ol.View({
            center: ol.proj.fromLonLat([120.5, -24.5]),
            zoom: 6
        })
    });

    // Fit map to Western Australia bounds
    const waExtent = ol.proj.transformExtent(WA_BOUNDS, 'EPSG:4326', 'EPSG:3857');
    map.getView().fit(waExtent, { padding: [50, 50, 50, 50] });

    // Store layer references and selection state
    const shapefileLayers = {};
    const selectedFeatures = new Map(); // shapefileId -> Set of feature IDs

    // Selection style
    const selectStyle = new ol.style.Style({
        stroke: new ol.style.Stroke({
            color: 'yellow',
            width: 4
        }),
        fill: new ol.style.Fill({
            color: 'rgba(255, 255, 0, 0.3)'
        })
    });

    // Update the select interaction to only select from processed layers
    const selectInteraction = new ol.interaction.Select({
        style: selectStyle,
        condition: ol.events.condition.click,
        layers: function(layer) {
            // Only select from processed vector layers
            return layer instanceof ol.layer.Vector && 
                Object.keys(shapefileLayers).some(key => 
                    key.endsWith('_processed') && shapefileLayers[key] === layer
                );
        }
    });

    // Add select interaction to map
    map.addInteraction(selectInteraction);

    // Update selection handler to only process processed layer features
    selectInteraction.on('select', function(e) {
        e.selected.forEach(function(feature) {
            const shapefileId = feature.get('shapefileId');
            const featureId = feature.get('featureId');
            const layerType = feature.get('layerType');
            
            // Only allow selection from processed layers
            if (layerType === 'processed') {
                if (!selectedFeatures.has(shapefileId)) {
                    selectedFeatures.set(shapefileId, new Set());
                }
                selectedFeatures.get(shapefileId).add(featureId);
            } else {
                // Remove selection from original layers
                selectInteraction.getFeatures().remove(feature);
            }
        });
        
        e.deselected.forEach(function(feature) {
            const shapefileId = feature.get('shapefileId');
            const featureId = feature.get('featureId');
            
            if (selectedFeatures.has(shapefileId)) {
                selectedFeatures.get(shapefileId).delete(featureId);
            }
        });
        
        updateAllSelectionInfo();
    });

    // Function to show status messages
    function showStatusMessage(message, type = 'info') {
        // Remove existing messages
        const existingMessages = document.querySelectorAll('.status-message');
        existingMessages.forEach(msg => msg.remove());
        
        // Create new message
        const messageDiv = document.createElement('div');
        messageDiv.className = `status-message alert alert-${type} alert-dismissible fade show`;
        messageDiv.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            min-width: 300px;
            max-width: 500px;
        `;
        
        let icon = 'ℹ️';
        if (type === 'success') icon = '✅';
        if (type === 'danger') icon = '❌';
        if (type === 'warning') icon = '⚠️';
        
        messageDiv.innerHTML = `
            ${icon} ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;
        
        document.body.appendChild(messageDiv);
        
        // Auto-dismiss after 5 seconds for success/info, 10 seconds for errors/warnings
        const dismissTime = type === 'success' || type === 'info' ? 5000 : 10000;
        setTimeout(() => {
            if (messageDiv.parentNode) {
                messageDiv.remove();
            }
        }, dismissTime);
    }

    // Layer control toggle functionality
    const layerToggleBtn = document.getElementById('layer-toggle-btn');
    const layerControl = document.getElementById('layer-control');

    layerToggleBtn.addEventListener('click', function() {
        if (layerControl.style.display === 'none') {
            layerControl.style.display = 'block';
        } else {
            layerControl.style.display = 'none';
        }
    });

    // Close layer control when clicking outside
    document.addEventListener('click', function(event) {
        if (!layerControl.contains(event.target) && !layerToggleBtn.contains(event.target)) {
            layerControl.style.display = 'none';
        }
    });

    // Function to load and display shapefile (updated with annotation support)
    function loadShapefile(shapefileId, layerType = 'original') {
        const layerKey = `${shapefileId}_${layerType}`;
        
        if (shapefileLayers[layerKey]) {
            shapefileLayers[layerKey].setVisible(true);
            if (layerType === 'processed') {
                zoomToLayer(shapefileLayers[layerKey]);
            }
            // Update annotations when layer visibility changes
            updateAnnotations();
            return;
        }

        const url = layerType === 'processed' 
            ? `/shapefile/${shapefileId}/geojson/processed/`
            : `/shapefile/${shapefileId}/geojson/`;

        fetch(url)
            .then(response => {
                if (!response.ok) {
                    if (layerType === 'processed' && response.status === 404) {
                        console.log(`No processed data for shapefile ${shapefileId}`);
                        return null;
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(geojsonData => {
                if (!geojsonData && layerType === 'processed') {
                    console.log(`Skipping processed layer for shapefile ${shapefileId} - no data`);
                    return;
                }

                const vectorSource = new ol.source.Vector({
                    features: geojsonData ? new ol.format.GeoJSON().readFeatures(geojsonData, {
                        dataProjection: 'EPSG:4326',
                        featureProjection: 'EPSG:3857'
                    }) : []
                });

                // Add feature IDs and metadata for selection
                vectorSource.getFeatures().forEach((feature, index) => {
                    feature.set('featureId', index.toString());
                    feature.set('shapefileId', shapefileId.toString());
                    feature.set('layerType', layerType);
                });

                const style = layerType === 'processed' 
                    ? new ol.style.Style({
                        stroke: new ol.style.Stroke({ color: 'red', width: 3 }),
                        fill: new ol.style.Fill({ color: 'rgba(255, 0, 0, 0.2)' })
                    })
                    : new ol.style.Style({
                        stroke: new ol.style.Stroke({ color: 'blue', width: 2 }),
                        fill: new ol.style.Fill({ color: 'rgba(0, 0, 255, 0.1)' })
                    });

                const vectorLayer = new ol.layer.Vector({ 
                    source: vectorSource, 
                    style: style
                });

                // Listen for visibility changes to update annotations
                vectorLayer.on('change:visible', function() {
                    setTimeout(updateAnnotations, 100);
                });

                map.addLayer(vectorLayer);
                shapefileLayers[layerKey] = vectorLayer;
                
                // Initialize selection set for this shapefile (only for processed layers)
                if (layerType === 'processed' && !selectedFeatures.has(shapefileId.toString())) {
                    selectedFeatures.set(shapefileId.toString(), new Set());
                }
                
                updateAllSelectionInfo();
                if (vectorSource.getFeatures().length > 0) {
                    zoomToLayer(vectorLayer);
                }
                
                // Update annotations after layer is loaded
                setTimeout(updateAnnotations, 200);
                
                console.log(`Loaded ${vectorSource.getFeatures().length} features for ${layerType} layer`);
            })
            .catch(error => {
                console.error(`Error loading ${layerType} shapefile:`, error);
                if (layerType === 'original') {
                    alert(`Error loading ${layerType} layer: ${error.message}`);
                }
            });
    }

    // Function to update selection info for all shapefiles
    function updateAllSelectionInfo() {
        // Clear existing selection info
        document.querySelectorAll('.selection-info').forEach(el => el.remove());
        
        // Update for each shapefile with processed data
        selectedFeatures.forEach((selectedSet, shapefileId) => {
            const selectionCount = selectedSet.size;
            const hasProcessedLayer = shapefileLayers.hasOwnProperty(`${shapefileId}_processed`);
            
            if (selectionCount > 0 && hasProcessedLayer) {
                const infoElement = document.createElement('div');
                infoElement.id = `selection-info-${shapefileId}`;
                infoElement.className = 'selection-info small text-muted mt-1';
                
                infoElement.innerHTML = `
                    <div><strong>Processed Layer Selection:</strong></div>
                    <div>Selected: ${selectionCount} polygon(s)</div>
                    <button class="btn btn-success btn-sm mt-1" onclick="mergeSelectedPolygons(${shapefileId})">
                        Merge Selected
                    </button>
                    <button class="btn btn-secondary btn-sm mt-1" onclick="clearSelection(${shapefileId})">
                        Clear
                    </button>
                `;
                
                const layerGroup = document.querySelector(`[id="layer${shapefileId}"]`).closest('.layer-group');
                if (layerGroup) {
                    layerGroup.appendChild(infoElement);
                }
            }
        });
        
        // Show message if trying to select from original layer
        const originalSelected = selectInteraction.getFeatures().getArray().some(feature => 
            feature.get('layerType') === 'original'
        );
        
        if (originalSelected) {
            showStatusMessage('Selection is only allowed from processed (red) layers', 'warning');
            // Clear selection from original layers
            const originalFeatures = selectInteraction.getFeatures().getArray().filter(feature => 
                feature.get('layerType') === 'original'
            );
            originalFeatures.forEach(feature => {
                selectInteraction.getFeatures().remove(feature);
            });
        }
    }

    // Update merge function to show proper status messages
    function mergeSelectedPolygons(shapefileId) {
        const shapefileIdStr = shapefileId.toString();
        
        if (!selectedFeatures.has(shapefileIdStr) || selectedFeatures.get(shapefileIdStr).size < 2) {
            showStatusMessage('Please select at least 2 polygons to merge from the processed layer', 'warning');
            return;
        }
        
        const selectedIds = Array.from(selectedFeatures.get(shapefileIdStr));
        
        console.log(`Attempting to merge shapefile ${shapefileId}, features: ${selectedIds}`);
        
        // Use GET request with URL parameters
        const mergeUrl = `/shapefile/${shapefileId}/merge/?ids=${JSON.stringify(selectedIds)}`;
        console.log(`Sending GET to: ${mergeUrl}`);
        
        showStatusMessage(`Merging polygons ${selectedIds.join(', ')}...`, 'info');
        
        fetch(mergeUrl, {
            method: 'GET',
            headers: {
                'X-CSRFToken': getCookie('csrftoken')
            }
        })
        .then(response => {
            console.log(`Response status: ${response.status}`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('Merge response:', data);
            if (data.success) {
                showStatusMessage(data.message, 'success');
                // Clear current selection
                clearSelection(shapefileId);
                
                // Reload the processed layer
                removeShapefile(shapefileId, 'processed');
                setTimeout(() => {
                    const processedCheckbox = document.getElementById(`layer${shapefileId}_processed`);
                    if (processedCheckbox) {
                        processedCheckbox.checked = true;
                        loadShapefile(shapefileId, 'processed');
                    } else {
                        // Create processed checkbox if it doesn't exist
                        const layerGroup = document.querySelector(`[id="layer${shapefileId}"]`).closest('.layer-group');
                        if (layerGroup) {
                            const originalLabel = document.querySelector(`[for="layer${shapefileId}"]`).textContent;
                            const processedHtml = `
                                <div class="form-check ms-3">
                                    <input class="form-check-input layer-checkbox" 
                                        type="checkbox" 
                                        value="${shapefileId}" 
                                        id="layer${shapefileId}_processed"
                                        data-layer-type="processed"
                                        checked>
                                    <label class="form-check-label" for="layer${shapefileId}_processed">
                                        ${originalLabel.replace('(O)', '(P)')}
                                    </label>
                                </div>
                            `;
                            layerGroup.querySelector('.form-check').insertAdjacentHTML('afterend', processedHtml);
                            loadShapefile(shapefileId, 'processed');
                        }
                    }
                }, 500);
            } else {
                showStatusMessage(data.message, 'danger');
            }
        })
        .catch(error => {
            console.error('Merge error:', error);
            showStatusMessage('Error merging polygons: ' + error.message, 'danger');
        });
    }

    // Update clear selection to show info
    function clearSelection(shapefileId) {
        const shapefileIdStr = shapefileId.toString();
        
        if (selectedFeatures.has(shapefileIdStr)) {
            selectedFeatures.get(shapefileIdStr).clear();
            
            // Clear selection from map
            const selectedFeaturesArray = selectInteraction.getFeatures().getArray();
            const featuresToDeselect = selectedFeaturesArray.filter(feature => 
                feature.get('shapefileId') === shapefileIdStr
            );
            
            featuresToDeselect.forEach(feature => {
                selectInteraction.getFeatures().remove(feature);
            });
            
            updateAllSelectionInfo();
            showStatusMessage('Selection cleared', 'info');
        }
    }

    // Update function to remove shapefile layer (with annotation cleanup)
    function removeShapefile(shapefileId, layerType = 'original') {
        const layerKey = `${shapefileId}_${layerType}`;
        if (shapefileLayers[layerKey]) {
            map.removeLayer(shapefileLayers[layerKey]);
            delete shapefileLayers[layerKey];
            
            // Also remove corresponding annotation layer
            const annotationKey = `${shapefileId}_${layerType}_annotations`;
            if (shapefileLayers[annotationKey]) {
                map.removeLayer(shapefileLayers[annotationKey]);
                delete shapefileLayers[annotationKey];
            }
            
            // Clear selection for this shapefile
            clearSelection(shapefileId);
            
            // Update annotations after removal
            updateAnnotations();
            
            if (Object.keys(shapefileLayers).length === 0) {
                map.getView().fit(waExtent, { padding: [50, 50, 50, 50], duration: 1000 });
            }
        }
    }

    // Function to zoom to a specific layer
    function zoomToLayer(layer) {
        const source = layer.getSource();
        const extent = source.getExtent();
        
        if (!ol.extent.isEmpty(extent)) {
            map.getView().fit(extent, {
                padding: [50, 50, 50, 50],
                maxZoom: 15,
                duration: 1000
            });
        }
    }

    // Update layer checkbox handler to manage annotations
    document.addEventListener('change', function(e) {
        if (e.target.classList.contains('layer-checkbox')) {
            const shapefileId = e.target.value;
            const layerType = e.target.dataset.layerType;
            
            if (e.target.checked) {
                loadShapefile(shapefileId, layerType);
            } else {
                removeShapefile(shapefileId, layerType);
            }
            
            // Update annotations after a short delay to ensure layer visibility has updated
            setTimeout(updateAnnotations, 300);
        }
    });

    // Update map view change to refresh annotations (for zoom/pan)
    map.getView().on('change:center', updateAnnotations);
    map.getView().on('change:resolution', updateAnnotations);


    // Load all checked layers initially
    document.querySelectorAll('.layer-checkbox:checked').forEach(checkbox => {
        const shapefileId = checkbox.value;
        const layerType = checkbox.dataset.layerType;
        loadShapefile(shapefileId, layerType);
    });

    // Auto-zoom to newly uploaded shapefile
    const urlParams = new URLSearchParams(window.location.search);
    const zoomToId = urlParams.get('zoom_to');
    
    if (zoomToId) {
        Object.keys(shapefileLayers).forEach(layerKey => {
            if (layerKey.startsWith(`${zoomToId}_`)) {
                const [shapefileId, layerType] = layerKey.split('_');
                removeShapefile(shapefileId, layerType);
            }
        });
        
        setTimeout(() => {
            const originalCheckbox = document.getElementById(`layer${zoomToId}`);
            if (originalCheckbox) {
                originalCheckbox.checked = true;
                loadShapefile(zoomToId, 'original');
            }
        }, 500);
        
        window.history.replaceState({}, document.title, window.location.pathname);
    }

    // CSRF token helper function
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    // Update the debug info function
    function updateDebugInfo() {
        const debugInfo = document.getElementById('debug-info');
        if (!debugInfo) return;
        
        const shapefileIds = Array.from(selectedFeatures.keys());
        let mergeUrl = '';
        
        if (shapefileIds.length > 0) {
            const firstShapefileId = shapefileIds[0];
            const selectedIds = Array.from(selectedFeatures.get(firstShapefileId));
            mergeUrl = `/shapefile/${firstShapefileId}/merge/?ids=${JSON.stringify(selectedIds)}`;
        }
        
        debugInfo.innerHTML = `
            Loaded shapefiles: ${Object.keys(shapefileLayers).join(', ')}<br>
            Selected features: ${JSON.stringify(Array.from(selectedFeatures.entries()))}<br>
            Merge URL: ${mergeUrl}
        `;
    }

    // Function to check if only one layer is visible
    function getVisibleLayersCount() {
        let count = 0;
        Object.values(shapefileLayers).forEach(layer => {
            if (layer.getVisible()) {
                count++;
            }
        });
        return count;
    }

    // Function to get representative point for a geometry
    function getRepresentativePoint(geometry) {
        if (geometry.getType() === 'Point') {
            return geometry.getCoordinates();
        } else if (geometry.getType() === 'Polygon') {
            // Use the first interior point or centroid as representative point
            try {
                return geometry.getInteriorPoint().getCoordinates();
            } catch (e) {
                return geometry.getExtent();
            }
        } else if (geometry.getType() === 'MultiPolygon') {
            // For MultiPolygon, use the first polygon's interior point
            const polygons = geometry.getPolygons();
            if (polygons.length > 0) {
                try {
                    return polygons[0].getInteriorPoint().getCoordinates();
                } catch (e) {
                    return polygons[0].getExtent();
                }
            }
        }
        // Fallback to centroid
        return geometry.getExtent();
    }

    // Function to create or update annotations
    function updateAnnotations() {
        // Remove existing annotations
        const existingAnnotationLayers = Object.keys(shapefileLayers).filter(key => key.endsWith('_annotations'));
        existingAnnotationLayers.forEach(key => {
            map.removeLayer(shapefileLayers[key]);
            delete shapefileLayers[key];
        });

        const visibleCount = getVisibleLayersCount();
        
        // Only show annotations if exactly one layer is visible
        if (visibleCount === 1) {
            // Find the single visible layer
            let targetLayer = null;
            let targetLayerKey = null;
            
            Object.entries(shapefileLayers).forEach(([key, layer]) => {
                if (layer.getVisible() && !key.endsWith('_annotations')) {
                    targetLayer = layer;
                    targetLayerKey = key;
                }
            });

            if (targetLayer && targetLayerKey) {
                const [shapefileId, layerType] = targetLayerKey.split('_');
                createAnnotationsForLayer(shapefileId, layerType, targetLayer);
            }
        }
    }

    // Function to create annotations for a specific layer
    function createAnnotationsForLayer(shapefileId, layerType, sourceLayer) {
        const annotationKey = `${shapefileId}_${layerType}_annotations`;
        const annotationSource = new ol.source.Vector();
        
        const features = sourceLayer.getSource().getFeatures();
        
        features.forEach((feature, index) => {
            const geometry = feature.getGeometry();
            const representativePoint = getRepresentativePoint(geometry);
            
            // Create point feature for annotation
            const pointFeature = new ol.Feature({
                geometry: new ol.geom.Point(representativePoint),
                index: index,
                shapefileId: shapefileId,
                layerType: layerType
            });
            
            annotationSource.addFeature(pointFeature);
        });

        const annotationLayer = new ol.layer.Vector({
            source: annotationSource,
            style: function(feature) {
                const index = feature.get('index');
                return new ol.style.Style({
                    text: new ol.style.Text({
                        text: index.toString(),
                        font: 'bold 14px Arial',
                        fill: new ol.style.Fill({
                            color: layerType === 'processed' ? '#ff0000' : '#0000ff'
                        }),
                        stroke: new ol.style.Stroke({
                            color: '#ffffff',
                            width: 3
                        }),
                        offsetY: 0,
                        textAlign: 'center',
                        textBaseline: 'middle'
                    })
                });
            },
            zIndex: 1000 // Ensure annotations appear above polygons
        });

        map.addLayer(annotationLayer);
        shapefileLayers[annotationKey] = annotationLayer;
        
        console.log(`Created annotations for ${features.length} features in ${layerType} layer`);
    }

    // Annotation toggle functionality
    let annotationsEnabled = true;
    const annotationToggleBtn = document.getElementById('annotation-toggle-btn');

    annotationToggleBtn.addEventListener('click', function() {
        annotationsEnabled = !annotationsEnabled;
        
        if (annotationsEnabled) {
            annotationToggleBtn.style.background = 'rgba(255, 255, 255, 0.9)';
            annotationToggleBtn.title = 'Hide Annotations';
            updateAnnotations();
            showStatusMessage('Annotations enabled', 'info');
        } else {
            annotationToggleBtn.style.background = 'rgba(200, 200, 200, 0.7)';
            annotationToggleBtn.title = 'Show Annotations';
            // Remove all annotation layers
            const annotationLayerKeys = Object.keys(shapefileLayers).filter(key => key.endsWith('_annotations'));
            annotationLayerKeys.forEach(key => {
                map.removeLayer(shapefileLayers[key]);
                delete shapefileLayers[key];
            });
            showStatusMessage('Annotations disabled', 'info');
        }
    });

</script>
</body>

</html>
