{% load static %}

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Shapefile Viewer</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@8.2.0/ol.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">

  <script src="{% static 'js/polygon_cutting.js' %}"></script>
  <script src="{% static 'js/merge_polygon.js' %}"></script>

  <style>
    .map {
      width: 100%;
      height: 600px;
    }
    .layer-control {
      position: absolute;
      top: 8.5em;
      left: 3.5em;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      z-index: 1000;
      max-width: 250px;
    }
    .layer-control-header {
      padding: 0.5em;
      border-bottom: 1px solid #dee2e6;
      background: rgba(248, 249, 250, 0.9);
      font-weight: bold;
      font-size: 0.9em;
    }
    .layer-control-body {
      padding: 0.5em;
      max-height: 400px;
      overflow-y: auto;
    }
    .layer-group {
      margin-bottom: 0.5em;
      padding-bottom: 0.5em;
      border-bottom: 1px solid #eee;
    }
    .layer-group:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }
    .form-check {
      margin-bottom: 0.25em;
    }
    .form-check-label {
      font-size: 0.8em;
    }
    .btn-sm {
      font-size: 0.7em;
      padding: 0.2em 0.5em;
    }
    .layer-toggle {
      position: absolute;
      top: 9.5em;
      left: 1.0em;
      z-index: 1000;
    }
    .layer-toggle-btn {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 2em;
      height: 2em;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .layer-toggle-btn:hover {
      background: white;
    }
    .bi-layers {
      font-size: 1em;
    }
    .selection-info {
      background: rgba(248, 249, 250, 0.8);
      padding: 0.5em;
      border-radius: 3px;
      border-left: 3px solid #28a745;
    }
    .annotation-toggle-btn:hover {
        background: white !important;
    }

    .bi-123 {
        font-size: 1em;
    }

    /* Cutting functionality styles */
    .cutting-toggle-btn:hover {
        background: white !important;
        color: #dc3545 !important;
    }

    .bi-scissors {
        font-size: 1em;
    }

    .cutting-panel .btn {
        margin-right: 0.25em;
        margin-bottom: 0.25em;
    }

    .cutting-instructions div {
        margin-bottom: 0.25em;
    }

    .cutting-status div {
        margin-bottom: 0.25em;
        padding: 0.25em;
        border-radius: 3px;
        background: rgba(0,0,0,0.05);
    }
    /* Temporary debug styles */
  </style>
</head>
<body>
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
    <div class="container">
      <a class="navbar-brand" href="{% url 'map_view' %}">Shapefile Viewer</a>
      <div class="navbar-nav">
        <a class="nav-link" href="{% url 'upload_shapefile' %}">Upload Shapefile</a>
      </div>
    </div>
  </nav>

  <div class="container-fluid mt-3">
    <div id="map" class="map"></div>
  </div>

  <!-- Add this temporarily for debugging -->
  <div style="position: absolute; bottom: 10px; left: 10px; background: white; padding: 10px; z-index: 1000;">
    <div id="debug-info" class="small"></div>
  </div>

  <!-- Layer Toggle Icon -->
  <div class="layer-toggle">
    <div class="layer-toggle-btn" id="layer-toggle-btn" title="Toggle Layers">
      <i class="bi bi-layers"></i>
    </div>
  </div>

    <!-- Add annotation toggle button next to layer toggle -->
    <div class="annotation-toggle" style="position: absolute; top: 4.5em; left: 3em; z-index: 1000;">
        <div class="annotation-toggle-btn" id="annotation-toggle-btn" title="Toggle Annotations" style="background: rgba(255, 255, 255, 0.9); border: 1px solid #ccc; border-radius: 4px; width: 2em; height: 2em; display: flex; align-items: center; justify-content: center; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">
            <i class="bi bi-123"></i>
        </div>
    </div>

    <!-- Cutting Toggle Button -->
    <div class="cutting-toggle" style="position: absolute; top: 4.5em; left: 5.5em; z-index: 1000;">
        <div class="cutting-toggle-btn" id="cutting-toggle-btn" title="Enable Polygon Cutting" style="background: rgba(255, 255, 255, 0.9); border: 1px solid #ccc; border-radius: 4px; width: 2em; height: 2em; display: flex; align-items: center; justify-content: center; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">
            <i class="bi bi-scissors"></i>
        </div>
    </div>

    <!-- Cutting Control Panel -->
    <div id="cutting-panel" class="cutting-panel" style="position: absolute; top: 7.5em; left: 0.5em; background: rgba(255, 255, 255, 0.95); border: 1px solid #dc3545; border-radius: 4px; padding: 0.75em; z-index: 1000; max-width: 280px; display: none; box-shadow: 0 2px 8px rgba(0,0,0,0.2);">
        <div class="cutting-panel-header" style="margin-bottom: 0.5em;">
            <h6 style="margin: 0; color: #dc3545;"><i class="bi bi-scissors"></i> Polygon Cutting</h6>
        </div>
        <div class="cutting-instructions small text-muted mb-2">
            <div>1. Click on a polygon from processed layer to select it</div>
            <div>2. Click anywhere on map to draw cut line points</div>
            <div>3. Line will cut where it intersects polygon</div>
            <div>4. Click "Cut Polygon" to execute</div>
        </div>
        <div class="cutting-status mb-2">
            <div id="cutting-selection-status" class="small">No polygon selected</div>
            <div id="cutting-line-status" class="small">No cut line drawn</div>
        </div>
        <div class="cutting-actions">
            <button id="cut-polygon-btn" class="btn btn-danger btn-sm" disabled>
                Cut Polygon
            </button>
            <button id="clear-cutting-btn" class="btn btn-outline-secondary btn-sm">
                Clear
            </button>
            <button id="close-cutting-btn" class="btn btn-outline-secondary btn-sm">
                Close
            </button>
        </div>
    </div>

    <!-- Temporary debug info -->
    <div style="position: absolute; bottom: 10px; left: 10px; background: white; padding: 10px; z-index: 1000; display: none;" id="cutting-debug">
        <div id="cutting-debug-info"></div>
    </div>

  <!-- Add cut toggle button next to annotation toggle -->
<!--
  <div class="cut-toggle" style="position: absolute; top: 4.5em; left: 5.5em; z-index: 1000;">
    <div class="cut-toggle-btn" id="cut-toggle-btn" title="Toggle Polygon Cutting" style="background: rgba(200, 200, 200, 0.7); border: 1px solid #ccc; border-radius: 4px; width: 2em; height: 2em; display: flex; align-items: center; justify-content: center; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">
        <i class="bi bi-scissors"></i>
    </div>
  </div>
-->

  <!-- Cut Control Panel -->
<!--
  <div id="cut-control-panel" class="cut-panel" style="display: none; position: absolute; top: 6.5em; left: 5.5em; background: rgba(255, 255, 255, 0.95); border: 1px solid #ccc; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); z-index: 1000; width: 320px; padding: 15px;">
    <div class="cut-panel-header" style="margin-bottom: 10px; display: flex; justify-content: between; align-items: center;">
        <h6 style="margin: 0;">Polygon Cutting</h6>
        <span id="cut-mode-status" class="badge bg-secondary">OFF</span>
    </div>
    <div class="cut-panel-body">
        <div class="mb-2">
            <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" id="cut-mode-toggle">
                <label class="form-check-label small" for="cut-mode-toggle">
                    <strong>Enable Cut Mode</strong>
                </label>
            </div>
        </div>
        
        <div class="mb-2 small text-muted">
            <p style="margin: 0; font-size: 0.8em;">
                <strong>Workflow:</strong><br>
                1. Enable Cut Mode<br>
                2. Select a red polygon<br>
                3. Start drawing cut line<br>
                4. Execute the cut
            </p>
        </div>
        
        <div id="cut-selection-info" class="small mb-2 p-2" style="border-radius: 3px; border-left: 3px solid #6c757d; background: #f8f9fa;">
            <strong>Status:</strong> Cut mode is disabled
        </div>
        
        <div class="d-grid gap-2">
            <button id="start-drawing-btn" class="btn btn-primary btn-sm" disabled>
                Start Drawing Cut Line
            </button>
            <button id="execute-cut-btn" class="btn btn-warning btn-sm" disabled>
                Execute Cut
            </button>
            <button id="clear-cut-btn" class="btn btn-secondary btn-sm">
                Clear Selection
            </button>
            <button id="cut-debug-btn" class="btn btn-info btn-sm">
                Debug Info
            </button>
        </div>
    </div>
  </div>
-->

  <!-- Layer Control Panel (hidden by default) -->
  <div id="layer-control" class="layer-control" style="display: none;">
    <div class="layer-control-header">
      Layers
    </div>
    <div class="layer-control-body">
      <div id="layer-list">
        {% for shapefile in shapefiles %}
        <div class="layer-group">
          <div class="form-check">
            <input class="form-check-input layer-checkbox" 
                   type="checkbox" 
                   value="{{ shapefile.id }}" 
                   id="layer{{ shapefile.id }}"
                   data-layer-type="original"
                   >
            <label class="form-check-label" for="layer{{ shapefile.id }}">
              {{ shapefile.name }} (O)
            </label>
          </div>
          
          {% if shapefile.geojson_data_processed %}
          <div class="form-check ms-3">
            <input class="form-check-input layer-checkbox" 
                   type="checkbox" 
                   value="{{ shapefile.id }}" 
                   id="layer{{ shapefile.id }}_processed"
                   data-layer-type="processed"
                   checked>
            <label class="form-check-label" for="layer{{ shapefile.id }}_processed">
              {{ shapefile.name }} (P)
            </label>
          </div>
          {% endif %}
          
          <div class="mt-1">
            <a href="{% url 'debug_shapefile' shapefile.id %}" class="btn btn-sm btn-outline-info" target="_blank">
              Debug
            </a>
          </div>
        </div>
        {% empty %}
        <p class="text-muted small">No shapefiles uploaded yet.</p>
        {% endfor %}
      </div>
      
      <div class="mt-3">
        <a href="{% url 'upload_shapefile' %}" class="btn btn-primary btn-sm w-100">Upload New Shapefile</a>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/ol@8.2.0/dist/ol.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
</body>

<script>
    // Debug function to show cutting state
    function updateCuttingDebug() {
        const debugInfo = document.getElementById('cutting-debug-info');
        if (debugInfo) {
            debugInfo.innerHTML = `
                Cutting: ${polygonCutter.isCuttingEnabled}<br>
                Selected: ${polygonCutter.selectedPolygon ? 'Yes' : 'No'}<br>
                Points: ${polygonCutter.cutLinePoints.length}<br>
            `;
        }
    }

    // Western Australia bounds (approximate)
    const WA_BOUNDS = [112.5, -35.5, 129.0, -13.5];

    // Initialize map with default controls (includes zoom buttons)
    const map = new ol.Map({
        target: 'map',
        layers: [
            new ol.layer.Tile({
                source: new ol.source.OSM()
            })
        ],
        view: new ol.View({
            center: ol.proj.fromLonLat([120.5, -24.5]),
            zoom: 6
        })
    });

    // Fit map to Western Australia bounds
    const waExtent = ol.proj.transformExtent(WA_BOUNDS, 'EPSG:4326', 'EPSG:3857');
    map.getView().fit(waExtent, { padding: [50, 50, 50, 50] });

    // Store layer references and selection state
    const shapefileLayers = {};
    const selectedFeatures = new Map(); // shapefileId -> Set of feature IDs

    // Create select interaction (update to allow selection from both layers for cutting)
    const selectInteraction = new ol.interaction.Select({
        condition: ol.events.condition.click,
        layers: function(layer) {
            // Allow selection from both layers, but cutting will only use processed
            return layer instanceof ol.layer.Vector && 
                Object.values(shapefileLayers).includes(layer);
        }
    });

    // Add select interaction to map
    map.addInteraction(selectInteraction);

    // Function to show status messages
    function showStatusMessage(message, type = 'info') {
        // Remove existing messages
        const existingMessages = document.querySelectorAll('.status-message');
        existingMessages.forEach(msg => msg.remove());
        
        // Create new message
        const messageDiv = document.createElement('div');
        messageDiv.className = `status-message alert alert-${type} alert-dismissible fade show`;
        messageDiv.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            min-width: 300px;
            max-width: 500px;
        `;
        
        let icon = 'ℹ️';
        if (type === 'success') icon = '✅';
        if (type === 'danger') icon = '❌';
        if (type === 'warning') icon = '⚠️';
        
        messageDiv.innerHTML = `
            ${icon} ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;
        
        document.body.appendChild(messageDiv);
        
        // Auto-dismiss after 5 seconds for success/info, 10 seconds for errors/warnings
        const dismissTime = type === 'success' || type === 'info' ? 5000 : 10000;
        setTimeout(() => {
            if (messageDiv.parentNode) {
                messageDiv.remove();
            }
        }, dismissTime);
    }

    // Layer control toggle functionality
    const layerToggleBtn = document.getElementById('layer-toggle-btn');
    const layerControl = document.getElementById('layer-control');

    layerToggleBtn.addEventListener('click', function() {
        if (layerControl.style.display === 'none') {
            layerControl.style.display = 'block';
        } else {
            layerControl.style.display = 'none';
        }
    });

    // Close layer control when clicking outside
    document.addEventListener('click', function(event) {
        if (!layerControl.contains(event.target) && !layerToggleBtn.contains(event.target)) {
            layerControl.style.display = 'none';
        }
    });

    // Function to load and display shapefile (updated with annotation support)
    function loadShapefile(shapefileId, layerType = 'original') {
        const layerKey = `${shapefileId}_${layerType}`;
        
        if (shapefileLayers[layerKey]) {
            shapefileLayers[layerKey].setVisible(true);
            if (layerType === 'processed') {
                zoomToLayer(shapefileLayers[layerKey]);
            }
            // Update annotations when layer visibility changes
            updateAnnotations();
            return;
        }

        const url = layerType === 'processed' 
            ? `/shapefile/${shapefileId}/geojson/processed/`
            : `/shapefile/${shapefileId}/geojson/`;

        fetch(url)
            .then(response => {
                if (!response.ok) {
                    if (layerType === 'processed' && response.status === 404) {
                        console.log(`No processed data for shapefile ${shapefileId}`);
                        return null;
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(geojsonData => {
                if (!geojsonData && layerType === 'processed') {
                    console.log(`Skipping processed layer for shapefile ${shapefileId} - no data`);
                    return;
                }

                const vectorSource = new ol.source.Vector({
                    features: geojsonData ? new ol.format.GeoJSON().readFeatures(geojsonData, {
                        dataProjection: 'EPSG:4326',
                        featureProjection: 'EPSG:3857'
                    }) : []
                });

                // Add feature IDs and metadata for selection
                vectorSource.getFeatures().forEach((feature, index) => {

                    let featureId;
                    
                    // First try to get ID from feature properties
                    const properties = feature.getProperties();
                    if (properties && properties.id !== undefined) {
                        featureId = properties.id.toString();
                    } else if (properties && properties.ID !== undefined) {
                        featureId = properties.ID.toString();
                    } else if (properties && properties.fid !== undefined) {
                        featureId = properties.fid.toString();
                    } else if (properties && properties.FID !== undefined) {
                        featureId = properties.FID.toString();
                    } else if (properties && properties.ogc_fid !== undefined) {
                        featureId = properties.ogc_fid.toString();
                    } 
                    // For merged polygons, use merged features info
                    else if (properties && properties.merged_features !== undefined) {
                        featureId = `merged_${shapefileId}_${index}`;
                    }
                    // For cut polygons, use original feature info
                    else if (properties && properties.original_feature !== undefined) {
                        featureId = properties.original_feature.toString();
                    }
                    // Fallback to index or OpenLayers internal ID
                    else if (feature.id_ !== undefined) {
                        featureId = feature.id_.toString();
                    } else {
                        // Final fallback - use index
                        featureId = index.toString();
                    }

                    feature.set('featureId', featureId);
                    feature.set('shapefileId', shapefileId.toString());
                    feature.set('layerType', layerType);
                });

                const style = layerType === 'processed' 
                    ? new ol.style.Style({
                        stroke: new ol.style.Stroke({ color: 'red', width: 3 }),
                        fill: new ol.style.Fill({ color: 'rgba(255, 0, 0, 0.2)' })
                    })
                    : new ol.style.Style({
                        stroke: new ol.style.Stroke({ color: 'blue', width: 2 }),
                        fill: new ol.style.Fill({ color: 'rgba(0, 0, 255, 0.1)' })
                    });

                const vectorLayer = new ol.layer.Vector({ 
                    source: vectorSource, 
                    style: style
                });

                // Listen for visibility changes to update annotations
                vectorLayer.on('change:visible', function() {
                    setTimeout(updateAnnotations, 100);
                });

                map.addLayer(vectorLayer);
                shapefileLayers[layerKey] = vectorLayer;
                
                // Initialize selection set for this shapefile (only for processed layers)
                if (layerType === 'processed' && !selectedFeatures.has(shapefileId.toString())) {
                    selectedFeatures.set(shapefileId.toString(), new Set());
                }
                
                if (typeof polygonMerger !== 'undefined') {
                    polygonMerger.updateAllSelectionInfo();
                }
                
                if (vectorSource.getFeatures().length > 0) {
                    zoomToLayer(vectorLayer);
                }
                
                // Update annotations after layer is loaded
                setTimeout(updateAnnotations, 200);
                
                console.log(`Loaded ${vectorSource.getFeatures().length} features for ${layerType} layer`);
            })
            .catch(error => {
                console.error(`Error loading ${layerType} shapefile:`, error);
                if (layerType === 'original') {
                    alert(`Error loading ${layerType} layer: ${error.message}`);
                }
            });
    }

    // Function to remove shapefile layer (with annotation cleanup)
    function removeShapefile(shapefileId, layerType = 'original') {
        const layerKey = `${shapefileId}_${layerType}`;
        if (shapefileLayers[layerKey]) {
            map.removeLayer(shapefileLayers[layerKey]);
            delete shapefileLayers[layerKey];
            
            // Also remove corresponding annotation layer
            const annotationKey = `${shapefileId}_${layerType}_annotations`;
            if (shapefileLayers[annotationKey]) {
                map.removeLayer(shapefileLayers[annotationKey]);
                delete shapefileLayers[annotationKey];
            }
            
            // Clear selection for this shapefile
            if (typeof polygonMerger !== 'undefined') {
                polygonMerger.clearSelection(shapefileId);
            }
            
            // Update annotations after removal
            updateAnnotations();
            
            if (Object.keys(shapefileLayers).length === 0) {
                map.getView().fit(waExtent, { padding: [50, 50, 50, 50], duration: 1000 });
            }
        }
    }

    // Function to zoom to a specific layer
    function zoomToLayer(layer) {
        const source = layer.getSource();
        const extent = source.getExtent();
        
        if (!ol.extent.isEmpty(extent)) {
            map.getView().fit(extent, {
                padding: [50, 50, 50, 50],
                maxZoom: 15,
                duration: 1000
            });
        }
    }

    // Update layer checkbox handler to manage annotations
    document.addEventListener('change', function(e) {
        if (e.target.classList.contains('layer-checkbox')) {
            const shapefileId = e.target.value;
            const layerType = e.target.dataset.layerType;
            
            if (e.target.checked) {
                loadShapefile(shapefileId, layerType);
            } else {
                removeShapefile(shapefileId, layerType);
            }
            
            // Update annotations after a short delay to ensure layer visibility has updated
            setTimeout(updateAnnotations, 300);
        }
    });

    // Update map view change to refresh annotations (for zoom/pan)
    map.getView().on('change:center', updateAnnotations);
    map.getView().on('change:resolution', updateAnnotations);

    // Load all checked layers initially
    document.querySelectorAll('.layer-checkbox:checked').forEach(checkbox => {
        const shapefileId = checkbox.value;
        const layerType = checkbox.dataset.layerType;
        loadShapefile(shapefileId, layerType);
    });

    // Auto-zoom to newly uploaded shapefile
    const urlParams = new URLSearchParams(window.location.search);
    const zoomToId = urlParams.get('zoom_to');
    
    if (zoomToId) {
        Object.keys(shapefileLayers).forEach(layerKey => {
            if (layerKey.startsWith(`${zoomToId}_`)) {
                const [shapefileId, layerType] = layerKey.split('_');
                removeShapefile(shapefileId, layerType);
            }
        });
        
        setTimeout(() => {
            const originalCheckbox = document.getElementById(`layer${zoomToId}`);
            if (originalCheckbox) {
                originalCheckbox.checked = true;
                loadShapefile(zoomToId, 'original');
            }
        }, 500);
        
        window.history.replaceState({}, document.title, window.location.pathname);
    }

    // CSRF token helper function
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    // Function to check if only one layer is visible
    function getVisibleLayersCount() {
        let count = 0;
        Object.values(shapefileLayers).forEach(layer => {
            if (layer.getVisible()) {
                count++;
            }
        });
        return count;
    }

    // Function to get representative point for a geometry
    function getRepresentativePoint(geometry) {
        if (geometry.getType() === 'Point') {
            return geometry.getCoordinates();
        } else if (geometry.getType() === 'Polygon') {
            // Use the first interior point or centroid as representative point
            try {
                return geometry.getInteriorPoint().getCoordinates();
            } catch (e) {
                return geometry.getExtent();
            }
        } else if (geometry.getType() === 'MultiPolygon') {
            // For MultiPolygon, use the first polygon's interior point
            const polygons = geometry.getPolygons();
            if (polygons.length > 0) {
                try {
                    return polygons[0].getInteriorPoint().getCoordinates();
                } catch (e) {
                    return polygons[0].getExtent();
                }
            }
        }
        // Fallback to centroid
        return geometry.getExtent();
    }

    // Function to create or update annotations
    function updateAnnotations() {
        // Remove existing annotations
        const existingAnnotationLayers = Object.keys(shapefileLayers).filter(key => key.endsWith('_annotations'));
        existingAnnotationLayers.forEach(key => {
            map.removeLayer(shapefileLayers[key]);
            delete shapefileLayers[key];
        });

        const visibleCount = getVisibleLayersCount();
        
        // Only show annotations if exactly one layer is visible
        if (visibleCount === 1) {
            // Find the single visible layer
            let targetLayer = null;
            let targetLayerKey = null;
            
            Object.entries(shapefileLayers).forEach(([key, layer]) => {
                if (layer.getVisible() && !key.endsWith('_annotations')) {
                    targetLayer = layer;
                    targetLayerKey = key;
                }
            });

            if (targetLayer && targetLayerKey) {
                const [shapefileId, layerType] = targetLayerKey.split('_');
                createAnnotationsForLayer(shapefileId, layerType, targetLayer);
            }
        }
    }

    // Function to create annotations for a specific layer
    function createAnnotationsForLayer(shapefileId, layerType, sourceLayer) {
        const annotationKey = `${shapefileId}_${layerType}_annotations`;
        const annotationSource = new ol.source.Vector();
        
        // Fetch the original GeoJSON to get the actual feature data from the API
        const url = layerType === 'processed' 
            ? `/shapefile/${shapefileId}/geojson/processed/`
            : `/shapefile/${shapefileId}/geojson/`;
        
        fetch(url)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(geojsonData => {
                if (!geojsonData || !geojsonData.features) {
                    console.log('No GeoJSON features found');
                    return;
                }
                
                console.log(`Creating annotations for ${geojsonData.features.length} features from API`);
                
                // Create annotations directly from the GeoJSON features
                geojsonData.features.forEach((feature, index) => {
                    if (!feature.geometry) return;
                    
                    // Get the actual feature ID - try multiple possible sources
                    let actualFeatureId = index; // Default to index
                    
                    // Try to get ID from feature properties
                    if (feature.properties) {
                        // Look for common ID fields in properties
                        if (feature.properties.id !== undefined) {
                            actualFeatureId = feature.properties.id;
                        } else if (feature.properties.ID !== undefined) {
                            actualFeatureId = feature.properties.ID;
                        } else if (feature.properties.fid !== undefined) {
                            actualFeatureId = feature.properties.fid;
                        } else if (feature.properties.FID !== undefined) {
                            actualFeatureId = feature.properties.FID;
                        } else if (feature.properties.ogc_fid !== undefined) {
                            actualFeatureId = feature.properties.ogc_fid;
                        }
                        // For cut polygons, use the original feature ID
                        else if (feature.properties.original_feature !== undefined) {
                            actualFeatureId = feature.properties.original_feature;
                        }
                        // For merged polygons, show merged info
                        else if (feature.properties.merged_features !== undefined) {
                            actualFeatureId = `M(${feature.properties.merged_features.length})`;
                        }
                    }
                    
                    // Use feature.id as last resort
                    if (feature.id !== undefined && feature.id !== null) {
                        actualFeatureId = feature.id;
                    }
                    
                    // Convert GeoJSON geometry to OpenLayers geometry
                    const olGeometry = new ol.format.GeoJSON().readGeometry(feature.geometry, {
                        dataProjection: 'EPSG:4326',
                        featureProjection: 'EPSG:3857'
                    });
                    
                    const representativePoint = getRepresentativePoint(olGeometry);
                    
                    // Create point feature for annotation
                    const pointFeature = new ol.Feature({
                        geometry: new ol.geom.Point(representativePoint),
                        index: actualFeatureId,  // Use the actual feature ID from API
                        shapefileId: shapefileId,
                        layerType: layerType,
                        originalProperties: feature.properties // Store for debugging
                    });
                    
                    annotationSource.addFeature(pointFeature);
                });

                const annotationLayer = new ol.layer.Vector({
                    source: annotationSource,
                    style: function(feature) {
                        const index = feature.get('index');
                        return new ol.style.Style({
                            text: new ol.style.Text({
                                text: index.toString(),
                                font: 'bold 14px Arial',
                                fill: new ol.style.Fill({
                                    color: layerType === 'processed' ? '#ff0000' : '#0000ff'
                                }),
                                stroke: new ol.style.Stroke({
                                    color: '#ffffff',
                                    width: 3
                                }),
                                offsetY: 0,
                                textAlign: 'center',
                                textBaseline: 'middle'
                            })
                        });
                    },
                    zIndex: 1000 // Ensure annotations appear above polygons
                });

                map.addLayer(annotationLayer);
                shapefileLayers[annotationKey] = annotationLayer;
                
                console.log(`Created annotations for ${geojsonData.features.length} features in ${layerType} layer using actual feature IDs`);
            })
            .catch(error => {
                console.error(`Error fetching GeoJSON for annotations:`, error);
            });
    }

    // Annotation toggle functionality
    let annotationsEnabled = true;
    const annotationToggleBtn = document.getElementById('annotation-toggle-btn');

    annotationToggleBtn.addEventListener('click', function() {
        annotationsEnabled = !annotationsEnabled;
        
        if (annotationsEnabled) {
            annotationToggleBtn.style.background = 'rgba(255, 255, 255, 0.9)';
            annotationToggleBtn.title = 'Hide Annotations';
            updateAnnotations();
            showStatusMessage('Annotations enabled', 'info');
        } else {
            annotationToggleBtn.style.background = 'rgba(200, 200, 200, 0.7)';
            annotationToggleBtn.title = 'Show Annotations';
            // Remove all annotation layers
            const annotationLayerKeys = Object.keys(shapefileLayers).filter(key => key.endsWith('_annotations'));
            annotationLayerKeys.forEach(key => {
                map.removeLayer(shapefileLayers[key]);
                delete shapefileLayers[key];
            });
            showStatusMessage('Annotations disabled', 'info');
        }
    });

    // Initialize functionality after DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize polygon merger
        polygonMerger = new PolygonMerger(
            map, 
            shapefileLayers, 
            selectedFeatures, 
            selectInteraction, 
            showStatusMessage
        );
        
        // Initialize polygon cutter
        setTimeout(() => {
            polygonCutter = new PolygonCutter(
                map, 
                shapefileLayers, 
                selectedFeatures, 
                selectInteraction, 
                showStatusMessage
            );
        }, 100);
    });
</script>

</html>
